<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>AWQ | Sunset</title>
<meta name="keywords" content="Quantization, Paper">
<meta name="description" content="Quantize된 가중치에 스케일링을 줘서 outlier를 따라하기">
<meta name="author" content="">
<link rel="canonical" href="https://new-sunset-shimmer.github.io/AWQ/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css" integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U&#43;6hYRq/Ez/nm5vg=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://new-sunset-shimmer.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://new-sunset-shimmer.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://new-sunset-shimmer.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://new-sunset-shimmer.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://new-sunset-shimmer.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://new-sunset-shimmer.github.io/AWQ/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><style>
    @media screen and (min-width: 769px) {

         
        .post-content input[type="checkbox"]:checked~label>img {
            transform: scale(1.6);
            cursor: zoom-out;
            position: relative;
            z-index: 999;
        }

        .post-content img.zoomCheck {
            transition: transform 0.15s ease;
            z-index: 999;
            cursor: zoom-in;
        }
    }
</style><meta property="og:title" content="AWQ" />
<meta property="og:description" content="Quantize된 가중치에 스케일링을 줘서 outlier를 따라하기" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://new-sunset-shimmer.github.io/AWQ/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-12-12T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-12-12T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="AWQ"/>
<meta name="twitter:description" content="Quantize된 가중치에 스케일링을 줘서 outlier를 따라하기"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://new-sunset-shimmer.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "AWQ",
      "item": "https://new-sunset-shimmer.github.io/AWQ/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "AWQ",
  "name": "AWQ",
  "description": "Quantize된 가중치에 스케일링을 줘서 outlier를 따라하기",
  "keywords": [
    "Quantization", "Paper"
  ],
  "articleBody": " Full Title : AWQ: ACTIVATION-AWARE WEIGHT QUANTIZATION FOR ON-DEVICE LLM COMPRESSION AND ACCELERATION\nLink : arxiv.org/pdf/2306.00978\nReleased Date : (MLSys 2024) Review Date : 2024 10 26\nQuantize된 가중치에 스케일링을 줘서 outlier를 따라하기\nMotivation PTQ는 따로 학습이 필요없이 모델의 사이즈와 계산량을 줄일수있는 장점이있다. 하지만 “Outlier”라는 중요한 벡터에 인해서 방법론에 인한 성능저하에 인해서 과연 효과적인지 의문을 가질수있다. 이번 논문은 그런 Outlier들을 quantization한뒤에 따라하는 방식을 제안했다. Research questions Local에서 돌릴수있는 모델을 만들수있을까? Methodology 저자들은 가중치중에서 거의 0.1%에서 1%프로만이 최종 결과에 영향을 미친다는걸 확인했다. 입력의 문맥에 맞는 소수의 가중치만 FP16으로 보존하면 성능에 영향을 미치지않는 양자화가 가능하다고 저자들은 생각한다. 하지만 그럴경우 계산속도는 여전히 비효율적이다. 저자들은 처음에 가중치가 양저화 됐을 때의 오류를 찾는 작업을 했다. s가 가장 최적으로 Perplexity를 보존하는 지점이 존재한다. - 일반 양자화 세모’은 s를 추가한 Quantization scalar 값이다. - Scale(s)를 추가한 양자화 - 각 양자화식의 오류 차이를 찾는 식 하지만 s를 직접찾는건 비 효율적인이다 그렇기에 저자들은 s를 찾는 식을 제안했다. 위의식으로는 직접적인 Gradient를 구할수 없기에 (Q 함수는 미분불가능) 분완전하다. 그렇기에 아래에 식을 적용함으로서 좀더 안전하게 학습한다. x는 활성화 함수를 지난 값이다. alpha를 통해서 [0,1] 얼마많큼의 가중치를 가져갈건지 정한다. Main result 해당논문은 가중치 그룹 양자화 방법론이다 . 그룹 사이즈는 128다. Calibratoin dataset은 Pile이다. 기본 양자화 방법은 RTN이다. Personal thought Activition도 양자화시 성능이 올라갈까? ",
  "wordCount" : "200",
  "inLanguage": "en",
  "datePublished": "2024-12-12T00:00:00Z",
  "dateModified": "2024-12-12T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://new-sunset-shimmer.github.io/AWQ/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Sunset",
    "logo": {
      "@type": "ImageObject",
      "url": "https://new-sunset-shimmer.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://new-sunset-shimmer.github.io/" accesskey="h" title="Sunset (Alt + H)">Sunset</a>
            <div class="logo-switches">
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://new-sunset-shimmer.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://new-sunset-shimmer.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://new-sunset-shimmer.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://new-sunset-shimmer.github.io/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      AWQ
    </h1>
    <div class="post-meta"><span title='2024-12-12 00:00:00 +0000 UTC'>December 12, 2024</span>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#motivation" aria-label="Motivation">Motivation</a></li>
                <li>
                    <a href="#research-questions" aria-label="Research questions">Research questions</a></li>
                <li>
                    <a href="#methodology" aria-label="Methodology">Methodology</a></li>
                <li>
                    <a href="#main-result" aria-label="Main result">Main result</a></li>
                <li>
                    <a href="#personal-thought" aria-label="Personal thought">Personal thought</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><blockquote>
<p>Full Title : AWQ: ACTIVATION-AWARE WEIGHT QUANTIZATION FOR
ON-DEVICE LLM COMPRESSION AND ACCELERATION</p>
</blockquote>
<blockquote>
<p>Link : <a href="https://arxiv.org/pdf/2306.00978">arxiv.org/pdf/2306.00978</a></p>
</blockquote>
<blockquote>
<p>Released Date : <a href="https://proceedings.mlsys.org/paper_files/paper/2024">(MLSys 2024) </a></p>
</blockquote>
<blockquote>
<p>Review Date : 2024 10 26</p>
</blockquote>
<p>Quantize된 가중치에 스케일링을 줘서 outlier를 따라하기</p>
<h3 id="motivation">Motivation<a hidden class="anchor" aria-hidden="true" href="#motivation">#</a></h3>
<ul>
<li>PTQ는 따로 학습이 필요없이 모델의 사이즈와 계산량을 줄일수있는 장점이있다. 하지만 “Outlier”라는 중요한 벡터에 인해서 방법론에 인한 성능저하에 인해서 과연 효과적인지 의문을 가질수있다. 이번 논문은 그런 Outlier들을 quantization한뒤에 따라하는 방식을 제안했다.</li>
</ul>
<h3 id="research-questions">Research questions<a hidden class="anchor" aria-hidden="true" href="#research-questions">#</a></h3>
<ul>
<li>Local에서 돌릴수있는 모델을 만들수있을까?</li>
</ul>
<h3 id="methodology">Methodology<a hidden class="anchor" aria-hidden="true" href="#methodology">#</a></h3>
<ul>
<li>저자들은 가중치중에서 거의 0.1%에서 1%프로만이 최종 결과에 영향을 미친다는걸 확인했다. 입력의 문맥에 맞는 소수의 가중치만 FP16으로 보존하면 성능에 영향을 미치지않는 양자화가 가능하다고 저자들은 생각한다. 하지만 그럴경우 계산속도는 여전히 비효율적이다.</li>
</ul>
<p>

<input type="checkbox" id="zoomCheck-a5928" hidden>
<label for="zoomCheck-a5928">
    <img class="zoomCheck" loading="lazy" decoding="async" src="/images/15a415f9-e659-8074-993b-d59aa8453c2d.png#center" alt=""  />
</label></p>
<ul>
<li>저자들은 처음에 가중치가 양저화 됐을 때의 오류를 찾는 작업을 했다. s가 가장 최적으로 Perplexity를 보존하는 지점이 존재한다.</li>
</ul>
<p>

<input type="checkbox" id="zoomCheck-c76a9" hidden>
<label for="zoomCheck-c76a9">
    <img class="zoomCheck" loading="lazy" decoding="async" src="/images/0cea6e01-0305-42ea-a03e-15bd9418d0c6.png#center" alt=""  />
</label></p>
<pre><code>- 일반 양자화 세모’은 s를 추가한 Quantization scalar 값이다.
</code></pre>
<p>

<input type="checkbox" id="zoomCheck-dc87b" hidden>
<label for="zoomCheck-dc87b">
    <img class="zoomCheck" loading="lazy" decoding="async" src="/images/86fd49ac-1e10-4181-bec1-ebaabf58516e.png#center" alt=""  />
</label></p>
<pre><code>- Scale(s)를 추가한 양자화
</code></pre>
<p>

<input type="checkbox" id="zoomCheck-15d41" hidden>
<label for="zoomCheck-15d41">
    <img class="zoomCheck" loading="lazy" decoding="async" src="/images/887e6811-74ed-4f5b-aeb3-626864f22e10.png#center" alt=""  />
</label></p>
<pre><code>- 각 양자화식의 오류 차이를 찾는 식
</code></pre>
<p>

<input type="checkbox" id="zoomCheck-edd39" hidden>
<label for="zoomCheck-edd39">
    <img class="zoomCheck" loading="lazy" decoding="async" src="/images/15a415f9-e659-8010-b864-f2e2b830ef27.png#center" alt=""  />
</label></p>
<ul>
<li>하지만 s를 직접찾는건 비 효율적인이다 그렇기에 저자들은 s를 찾는 식을 제안했다.</li>
</ul>
<p>

<input type="checkbox" id="zoomCheck-45f72" hidden>
<label for="zoomCheck-45f72">
    <img class="zoomCheck" loading="lazy" decoding="async" src="/images/fcea5e3b-176e-4db2-a0de-2eeb94ab3f53.png#center" alt=""  />
</label></p>
<pre><code>위의식으로는 직접적인 Gradient를 구할수 없기에 (Q 함수는 미분불가능) 분완전하다. 그렇기에 아래에 식을 적용함으로서 좀더 안전하게 학습한다. x는 활성화 함수를 지난 값이다. alpha를 통해서 [0,1] 얼마많큼의 가중치를 가져갈건지 정한다.
</code></pre>
<p>

<input type="checkbox" id="zoomCheck-188a7" hidden>
<label for="zoomCheck-188a7">
    <img class="zoomCheck" loading="lazy" decoding="async" src="/images/15a415f9-e659-802f-b59f-c8b3f75ccd93.png#center" alt=""  />
</label></p>
<p>

<input type="checkbox" id="zoomCheck-1c0a3" hidden>
<label for="zoomCheck-1c0a3">
    <img class="zoomCheck" loading="lazy" decoding="async" src="/images/15a415f9-e659-80e0-9b7b-ccd7d20f3c65.png#center" alt=""  />
</label></p>
<h3 id="main-result">Main result<a hidden class="anchor" aria-hidden="true" href="#main-result">#</a></h3>
<ul>
<li>해당논문은 가중치 그룹 양자화 방법론이다 . 그룹 사이즈는 128다. Calibratoin dataset은 Pile이다. 기본 양자화 방법은 RTN이다.</li>
</ul>
<p>

<input type="checkbox" id="zoomCheck-8f4e9" hidden>
<label for="zoomCheck-8f4e9">
    <img class="zoomCheck" loading="lazy" decoding="async" src="/images/15a415f9-e659-8017-ad76-f087dba8e1ee.png#center" alt=""  />
</label></p>
<p>

<input type="checkbox" id="zoomCheck-64b98" hidden>
<label for="zoomCheck-64b98">
    <img class="zoomCheck" loading="lazy" decoding="async" src="/images/15a415f9-e659-80c4-83b0-e5a13315f882.png#center" alt=""  />
</label></p>
<p>

<input type="checkbox" id="zoomCheck-9ed49" hidden>
<label for="zoomCheck-9ed49">
    <img class="zoomCheck" loading="lazy" decoding="async" src="/images/15a415f9-e659-80fc-846d-cb256a70e5a8.png#center" alt=""  />
</label></p>
<p>

<input type="checkbox" id="zoomCheck-0211a" hidden>
<label for="zoomCheck-0211a">
    <img class="zoomCheck" loading="lazy" decoding="async" src="/images/15a415f9-e659-8085-80c7-d6a6fffe7e14.png#center" alt=""  />
</label></p>
<p>

<input type="checkbox" id="zoomCheck-293a2" hidden>
<label for="zoomCheck-293a2">
    <img class="zoomCheck" loading="lazy" decoding="async" src="/images/15a415f9-e659-80de-ba69-d5c5daa637d4.png#center" alt=""  />
</label></p>
<hr>
<h3 id="personal-thought">Personal thought<a hidden class="anchor" aria-hidden="true" href="#personal-thought">#</a></h3>
<ol>
<li>Activition도 양자화시 성능이 올라갈까?</li>
</ol>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://new-sunset-shimmer.github.io/tags/quantization/">Quantization</a></li>
      <li><a href="https://new-sunset-shimmer.github.io/tags/paper/">Paper</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://new-sunset-shimmer.github.io/">Sunset</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
